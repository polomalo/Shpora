import React from 'react'
import virtualdom from '../images/virtualdom.webp'

const VirtualDOM = () => {
  return (
    <div className="content-block">
      <h2 className="content-title">VirtualDOM. Reconciliation. Fiber</h2>
      <hr />
      <div className="content-text">
        <p>
          Давай начнем с основ. DOM - это сокращение от "Document Object Model"
          (объектная модель документа). Когда ты открываешь веб-страницу в
          браузере, браузер создает структуру документа, которую можно
          представить в виде дерева элементов. Эти элементы - это HTML-теги,
          например, <code>{`<div>, <p>, <h1>`}</code> и другие. DOM позволяет
          нам манипулировать этой структурой, изменять содержимое, стили,
          добавлять и удалять элементы.
        </p>
        <p>
          Теперь представь, что у тебя есть большое React-приложение с
          множеством компонентов и элементов. Каждый раз, когда происходит
          изменение данных в приложении, React должен обновить DOM, чтобы
          отобразить эти изменения на странице. Но вместо того, чтобы
          непосредственно вносить изменения в реальный DOM, React использует
          виртуальный DOM.
        </p>
        <p>
          Виртуальный DOM - это промежуточное представление DOM в памяти
          компьютера. React создает виртуальное дерево элементов, которое точно
          соответствует текущему состоянию компонентов. Затем React сравнивает
          это виртуальное дерево с реальным DOM и определяет, какие изменения
          необходимо внести.
        </p>
      </div>
      <div className="content-img">
        <img src={virtualdom} alt="" />
      </div>
      <h2 className="content-title">Reconciliation</h2>
      <div className="content-text">
        <p>
          Reconciliation – это процесс, при котором React сравнивает предыдущее
          и новое состояние компонента, определяя минимальный набор изменений,
          который нужно внести в пользовательский интерфейс.
        </p>
      </div>
      <h3 className="content-title">Зачем это нужно?</h3>
      <div className="content-text">
        <p>
          Представь, что у тебя есть React-компонент, который отображает данные.
          Когда пользователь вводит новый текст или получает обновления с
          сервера, React должен обновить интерфейс, но без лишних перерисовок.
          Именно этим занимается Reconciliation – он делает обновления
          максимально эффективными.
        </p>
      </div>
      <hr />
      <h3 className="content-title">Как работает Reconciliation?</h3>
      <div className="content-text">
        <ol>
          <li>
            <ul>
              <p>Обновление состояния</p>
              <li>
                Когда меняется state или props, React запускает процесс
                Reconciliation.
              </li>
              <li>
                Он создаёт новое Virtual DOM-дерево для текущего состояния.
              </li>
            </ul>
          </li>
          <li>
            <ul>
              <p>Сравнение элементов (Diffing Algorithm)</p>
              <li>React построчно сравнивает новый Virtual DOM со старым.</li>
              <li>Если элемент не изменился, он остаётся нетронутым.</li>
              <li>
                Если изменился текст или пропсы – React обновляет только нужную
                часть.
              </li>
              <li>Если элемент удалён или добавлен, React пересоздаёт его.</li>
            </ul>
          </li>
          <li>
            <ul>
              <p>Обновление реального DOM</p>
              <li>
                React находит разницу (diff) между старыми и новыми элементами.
              </li>
              <li>
                Обновляет только изменённые части DOM, избегая ненужных
                ререндеров.
              </li>
            </ul>
          </li>
        </ol>
      </div>
      <div className="content-text">
        <p>
          <b>Вывод:</b> Reconciliation делает React молниеносным, потому что он
          не перерисовывает весь интерфейс, а только изменённые элементы.
        </p>
      </div>
      <hr />
      <h3 className="content-title">Fiber</h3>
      <div className="content-text">
        <p>
          Когда React только появился, он был быстрым, но с ростом проектов
          старый механизм обновлений начал тормозить.
        </p>
        <p>
          Представь, что у тебя огромное приложение, где обновляются и список
          товаров, и форма ввода, и анимация. Если обновлять всё сразу –
          интерфейс может замереть на мгновение, создавая неприятные лаги.
        </p>
        <p>
          Чтобы решить эту проблему, React представил Fiber – новый движок
          рендеринга, который сделал обновления плавными, предсказуемыми и
          суперэффективными.
        </p>
      </div>
      <h3 className="content-title">Что изменилось с Fiber?</h3>
      <div className="content-text">
        <p>
          <b>Раньше (до Fiber)</b>
        </p>
        <ol>
          <li>React обновлял весь Virtual DOM за один проход.</li>
          <li>
            Если обновление занимало слишком много времени – интерфейс подвисал.
          </li>
          <li>
            Нельзя было приостанавливать или отменять обновления – React всегда
            доводил их до конца.
          </li>
        </ol>
      </div>
      <div className="content-text">
        <p>
          <b>Теперь (с Fiber)</b>
        </p>
        <ol>
          <li>
            Обновления разбиваются на части – React может приостанавливать
            рендеринг и продолжать его позже.
          </li>
          <li>
            Важные обновления в приоритете – ввод в input и клики обновляются
            раньше, чем менее важные изменения.
          </li>
          <li>
            Браузер больше не замирает – React даёт ему время на анимации,
            прокрутку и другие задачи.
          </li>
        </ol>
      </div>
    </div>
  )
}

export default VirtualDOM
